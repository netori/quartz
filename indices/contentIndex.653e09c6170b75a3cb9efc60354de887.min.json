{"/":{"title":"index","content":"## Abstract\nThis page references other indices.\n- [[_technical|Technical Information Hub]]\n- [[_日本語|日本語]]\n","lastmodified":"2023-03-12T06:17:48.960343308Z","tags":null},"/%E6%97%A5%E6%9C%AC%E8%AA%9E/%E8%A8%98%E4%BA%8B%E3%82%92%E8%AA%AD%E3%81%BF%E3%81%BE%E3%81%97%E3%81%9F":{"title":"記事を読みました","content":"## 概要\n[NHK](https://www3.nhk.or.jp/news/easy/)から記事を読みました。\n","lastmodified":"2023-03-12T06:17:48.960343308Z","tags":null},"/_%E6%97%A5%E6%9C%AC%E8%AA%9E":{"title":"日本語","content":"## 概要\nこの欄は日本語を学ぶためものです。\n\n日本語は私の第一言語ではありません。でも私は学びたいです。\n\nよろしくお願いします。\n\n## リンク\n- [[日本語/記事を読みました|記事を読みました]]\n\n","lastmodified":"2023-03-12T06:17:48.960343308Z","tags":null},"/_technical":{"title":"Technical Information Hub","content":"## Abstract\nThis page collects technical information about things of interest.\n- [[node/Beat Angel Escalayer R|Beat Angel Escalayer R]]\n- [[node/Rance IX|Rance IX]]\n- [[node/System Virtual Machine|System VM]]\n- [[node/Future Projects|Future Projects]]\n- [[node/Data Science|Data Science]]\n","lastmodified":"2023-03-12T06:17:48.960343308Z","tags":null},"/node/Application-Virtualization":{"title":"Application Virtualization","content":"## Abstract\nThis page collects relevant information regarding programs that run through a virtual machine.\n\n## Bytecode Handler\nThe execution units that are assigned to a specific bytecode are commonly referred to as handlers.  \n  \nA common practice in reversing virtualised malware, or virtual machines is to follow a process called _lifting, translating, and repackaging_; whereby, the reverse engineer determines exactly what each handler does (_lifting_), somehow convert the information into a language that the CPU and disassemblers understand (_translating_), and finally repackaging the binary (_repackaging_). It's tedious and complicated, but there already are existing tools for the System interpreter like the tools that I had mentioned in my post.","lastmodified":"2023-03-12T06:17:48.960343308Z","tags":null},"/node/Beat-Angel-Escalayer-R":{"title":"Beat Angel Escalayer R","content":"## Abstract\nBeat Angel Escalayer R (*BEAR*) is a game made by AliceSoft, and its instructions are interpreted using Alicesoft's proprietary virtual machine (VM): [[node/System Virtual Machine|System]]. \n\n*BEAR* has turn-based battles between player-controlled characters and AI opponents. After crafting an exploit for [[node/Rance IX|Rance IX]], I then looked at this game due to its AntiCheat features. Specifically, the AntiCheat stores an encrypted copy of data to a buffer, performs a comparison between the copy and new data, and triggers a death flag if there's an inequality, otherwise, the encrypted copy is replaced with the new data. This death flag causes the character to die on the next turn.\n\nI utilised [[node/System Virtual Machine#Tools|tools]] designed for the System architecture combined with my previous knowledge to craft a simple exploit for *BEAR*. Largely reminiscent of ACTk for Unity.\n\n## Decompile *ain* file\n``` c#\nint C_INT::Get()\n{\n\tSH_LOCALDELETE(0);\n\tC_VALUE_ENCRYPTION cValueEncryption = SH_LOCALCREATE(0, 194);\n\tint nXorKey = this.GetKey();\n\tint nValue = cValueEncryption.Decryption(this.m_nCode, nXorKey, this.GetCodePattern());\n\tint nBackUp = cValueEncryption.Decryption(this.m_nBackUpCode, nXorKey, this.GetBackUpCodePattern());\n\tif (!system.IsDebugMode())\n\t{\n\t\tif (nValue != nBackUp)\n\t\t{\n\t\t\t■チート疑惑設定(true); //Cheat Suspected\n\t\t\tnValue = 0;\n\t\t}\n\t\tif (this.m_nValue != nValue)\n\t\t{\n\t\t\t■チート疑惑設定(true); //Cheat Suspected\n\t\t}\n\t\treturn nValue;\n\t}\n\tif (this.m_nValue != nValue)\n\t{\n\t\tthis.Set(this.m_nValue);\n\t}\n\treturn this.m_nValue;\n\treturn 0;\n}\n```\n\n## Craft Exploit","lastmodified":"2023-03-12T06:17:48.960343308Z","tags":null},"/node/Data-Science":{"title":"Data Science","content":"## Abstract\n","lastmodified":"2023-03-12T06:17:48.960343308Z","tags":null},"/node/Future-Projects":{"title":"Future Projects","content":"## Abstract\nTools for future projects.\n- https://kroki.io\n- https://github.com/mermaid-js/mermaid\n- https://docs.swimm.io\n","lastmodified":"2023-03-12T06:17:48.960343308Z","tags":null},"/node/Rance-IX":{"title":"Rance IX","content":"## Abstract\nRance IX is a game made by AliceSoft, and its instructions are interpreted using Alicesoft's proprietary virtual machine (VM): [[node/System Virtual Machine|System4]]. \n\nI crafted an exploit for Rance IX by determining where and how the System interpreter fetches instructions, how these instructions are decoded, and finally writing my own [Cheat Engine](https://cheatengine.org/) scripts to rewrite how these instructions are executed.\n\n## Binary Analysis\nAfter reading through [[node/System Virtual Machine#System4 Analysis|System4 Analysis]], I know that I will be dealing with some form of virtual machine and virtualized functions. \n\nIn general, virtualized functions will have their own instruction pointer and stack space. For a virtualized function to interface with these memory components, it can utilise hardware registers, stack, and heap to communicate changes. Therefore, to prevent any corruption, a virtualized function must preserve the context of the function that called it, and restore it. Preservation is usually found at the function prologue; on the other hand, restoration is usually found at the function epilogue.\n\nRespectively, they are called `VM Entry` and `VM Exit`.\n\nWith this knowledge, I started to reverse-engineer the game binary.\n\n### Inside a Handler\nI scanned for basic character properties (health, damage, gold, etc.) and set watchpoints on those properties to alert any access. Changing those properties in the game triggered the watchpoint and led me to the subroutine that accessed those properties.\n\n![[images/ranceix-vm-access.png]]\n*A snippet of the subroutine with some modifications that accessed the character properties.*\n\nTo determine the subroutine's intention in its parent function, I used IDA's graph analysis to display the parent function's control-flow. \n\n![[images/system42-interprepter.png]]\n*The subroutine is actually a case within this huge function's switch-case statement.*\n\nThe subroutine's parent function is actually the dispatcher for some input of bytecode from an *ain* script; it's a gargantuan switch-case statement (with over 200 cases) where each case is assigned to a specific bytecode that the System interpreter will handle.\n\n###  Finding `VM Entry`\nRealising that I am inside a virtualized function, finding `VM Entry` is relatively easy; trace upwards to the beginning of the function (i.e. the instructions before the dispatch).\n\n![[images/ranceix-vm-entry.png]]\n*A snippet of `VM Entry` with some modification.*\n\n### Execution Cycle\nSince the dispatcher takes bytecode as an argument, listing cross-references to `VM Entry` led me to a subroutine `loc_575D20`.\n\n![[images/ranceix-vm-loop.png]]\n*A subroutine that continuously calls `VM Entry`*\n\nAfter some debugging, this subroutine is a loop that inputs bytecode from an *ain* script as an argument to `VM Entry`, increments the virtual machine instruction pointer, and calls `VM Entry`. This loop continues indefinitely until there is a signal from `*(CJaffaVM + 0x234)` to exit.\n\nIn C code, this is how the execution cycle would look like....\n```c\ndo\n{\n  vm_ip = *(CJaffaVM + 0x224);\n  bytecode = *vm_ip;\n  *(CJaffaVM + 0x224) = vm_ip + 1;\n  vm_entry(CJaffaVM, unknown1, unknown2, bytecode);\n}\nwhile ( !*(CJaffaVM + 0x234) );\n```\n\n### Bytecode Storage\nAfter some more reverse-engineering, I found out where the bytecode was being stored.\n\n## Craft Exploit\nSince game values are stored in `CPage` instances, I created a thread to interface with these components and, if necessary, temporarily lock the execution cycle. I created a thread instead of directly hooking the execution cycle, since the game will lag.\n\nThe script can be found [here](https://fearlessrevolution.com/viewtopic.php?f=2\u0026t=23630\u0026sid=9dd754c98ad76236735299b9f017dbae\u0026start=15), just look a few posts down.\n","lastmodified":"2023-03-12T06:17:48.960343308Z","tags":null},"/node/System-Virtual-Machine":{"title":"System Virtual Machine","content":"## Abstract\nSystem is a process virtual machine designed by AliceSoft to increase accessibility between different computer platforms. \n\n\u003e [!quote] Brief by [AliceSoft Fandom](https://alicesoft.fandom.com/wiki/System)\n\u003e\n\u003e **System** is a series of OS/VM hybrids that was designed by [Alice Soft](https://www.alicesoft.com/) to cope with porting their games across different computer platforms. This was especially important in the early days of Alice Soft's history, when there were multiple prevalent families of computers ([PC-98](http://en.wikipedia.org/wiki/NEC_PC-9801 \"wikipedia:NEC PC-9801\"), [x68k](http://en.wikipedia.org/wiki/x68k \"wikipedia:x68k\"), [FM-Towns](http://en.wikipedia.org/wiki/FM-Towns \"wikipedia:FM-Towns\") etc) competing on the Japanese PC market. A similar strategy was used by other developers at the time, such as [Infocom](http://en.wikipedia.org/wiki/Infocom \"wikipedia:Infocom\")'s famous Z-Machine interpreter.\n\n## Environment\nSystem is a virtual machine that interprets Alicesoft's proprietary game files (*.ain*, *.jaf*, *.jam*, etc.).\n\n![System-Interprepter](images/system42-interprepter.png)*A graph disassembly produced by IDA of a portion of the System VM.*\n\nThe above graph is a portion of the System interpreter; it's a gargantuan switch-case statement (with over 100 cases), and each case pertains to a particular bytecode that the System interpreter will execute. The execution units that are assigned to a specific bytecode are commonly referred to as handlers.  \n\nA common practice in reverse-engineering virtualized malware, or virtual machines is to follow a process called _lifting, translating, and repackaging_; whereby, the reverse engineer determines exactly what each handler does (_lifting_), somehow convert the information into a language that the CPU and disassemblers understand (_translating_), and finally repackaging the binary (_repackaging_). It's tedious and complicated, but there already are existing tools for the System VM.\n\n## System4 Analysis\nSystem4 is a model of heap virtual machine architecture. It has an entry and an exit, calculations that are applied to datum located inside its memory heap, and a dispatcher to individual handlers for some inputted bytecode. These core concepts can be explained [here](https://www.youtube.com/watch?v=b6udPT79itk).\n\n### `CJaffaVM`\n`CJaffaVM` (denoted by RTTI) is an object that governs the System virtual machine. There is only **one** instance of this object; moreover, there is always a static address that points to this instance.\n\n### `CPage`\n`CPage` (denoted by RTTI) is an object that contains game variables and in-game values. There are at least a hundred of these instances.\n\n### `CPage` Array\nThe `CPage` Array contains all `CPage` instances.\n\n## Resources\nThe following hyperlinks lead to some insightful references to the System VM.\n\n### Tools\n- [alice-tools](https://github.com/nunuhara/alice-tools) - Incredibly useful tool for extracting/editing files from AliceSoft games.\n- [ain decompiler](https://github.com/UserUnknownFactor/AinDecompiler) -  Fantastic tool developed by **SomeLoliCatGirl** that decompiles *ain* file formats into native System bytecode.\n\n### General\n- [haniwa.technology](https://haniwa.technology/) - This site collects technical information and resources relating to games and game engines developed by AliceSoft.\n- [xsystem4](https://github.com/nunuhara/xsystem4) - System4 for UNIX-like operating systems\n\n### Uses System\n- [[node/Beat Angel Escalayer R]]\n- The Rance Series\n\t- [[node/Rance IX |Rance IX]]","lastmodified":"2023-03-12T06:17:48.960343308Z","tags":null}}